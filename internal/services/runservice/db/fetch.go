// Code generated by go generate; DO NOT EDIT.
package db

import (
	stdsql "database/sql"
	"encoding/json"

	"agola.io/agola/internal/errors"
	"agola.io/agola/internal/sql"
	"agola.io/agola/services/runservice/types"

	sq "github.com/Masterminds/squirrel"
)

func (d *DB) fetchSequences(tx *sql.Tx, q sq.Sqlizer) ([]*types.Sequence, []string, error) {
	rows, err := d.query(tx, q)
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	defer rows.Close()

	return d.scanSequences(rows)
}

func (d *DB) scanSequence(rows *stdsql.Rows, additionalFields []interface{}) (*types.Sequence, string, error) {
	var id string
	var revision uint64
	var data []byte
	fields := append([]interface{}{&id, &revision, &data}, additionalFields...)
	if err := rows.Scan(fields...); err != nil {
		return nil, "", errors.Wrap(err, "failed to scan rows")
	}
	v := types.Sequence{}
	if len(data) > 0 {
		if err := json.Unmarshal(data, &v); err != nil {
			return nil, "", errors.Wrap(err, "failed to unmarshal Sequence")
		}
	}

	v.Revision = revision

	return &v, id, nil
}

func (d *DB) scanSequences(rows *stdsql.Rows) ([]*types.Sequence, []string, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	fieldsNumber := len(cols)
	if fieldsNumber < 3 {
		return nil, nil, errors.Errorf("not enough columns (%d < 3)", len(cols))
	}
	var additionalFieldsPtr []interface{}
	if fieldsNumber > 3 {
		additionalFieldsNumber := fieldsNumber - 3
		additionalFields := make([]interface{}, additionalFieldsNumber)
		additionalFieldsPtr = make([]interface{}, additionalFieldsNumber)
		for i := 0; i < additionalFieldsNumber; i++ {
			additionalFieldsPtr[i] = &additionalFields[i]
		}
	}

	vs := []*types.Sequence{}
	ids := []string{}
	for rows.Next() {
		v, id, err := d.scanSequence(rows, additionalFieldsPtr)
		if err != nil {
			rows.Close()
			return nil, nil, errors.WithStack(err)
		}
		vs = append(vs, v)
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, nil, errors.WithStack(err)
	}
	return vs, ids, nil
}

func (d *DB) fetchChangeGroups(tx *sql.Tx, q sq.Sqlizer) ([]*types.ChangeGroup, []string, error) {
	rows, err := d.query(tx, q)
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	defer rows.Close()

	return d.scanChangeGroups(rows)
}

func (d *DB) scanChangeGroup(rows *stdsql.Rows, additionalFields []interface{}) (*types.ChangeGroup, string, error) {
	var id string
	var revision uint64
	var data []byte
	fields := append([]interface{}{&id, &revision, &data}, additionalFields...)
	if err := rows.Scan(fields...); err != nil {
		return nil, "", errors.Wrap(err, "failed to scan rows")
	}
	v := types.ChangeGroup{}
	if len(data) > 0 {
		if err := json.Unmarshal(data, &v); err != nil {
			return nil, "", errors.Wrap(err, "failed to unmarshal ChangeGroup")
		}
	}

	v.Revision = revision

	return &v, id, nil
}

func (d *DB) scanChangeGroups(rows *stdsql.Rows) ([]*types.ChangeGroup, []string, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	fieldsNumber := len(cols)
	if fieldsNumber < 3 {
		return nil, nil, errors.Errorf("not enough columns (%d < 3)", len(cols))
	}
	var additionalFieldsPtr []interface{}
	if fieldsNumber > 3 {
		additionalFieldsNumber := fieldsNumber - 3
		additionalFields := make([]interface{}, additionalFieldsNumber)
		additionalFieldsPtr = make([]interface{}, additionalFieldsNumber)
		for i := 0; i < additionalFieldsNumber; i++ {
			additionalFieldsPtr[i] = &additionalFields[i]
		}
	}

	vs := []*types.ChangeGroup{}
	ids := []string{}
	for rows.Next() {
		v, id, err := d.scanChangeGroup(rows, additionalFieldsPtr)
		if err != nil {
			rows.Close()
			return nil, nil, errors.WithStack(err)
		}
		vs = append(vs, v)
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, nil, errors.WithStack(err)
	}
	return vs, ids, nil
}

func (d *DB) fetchRuns(tx *sql.Tx, q sq.Sqlizer) ([]*types.Run, []string, error) {
	rows, err := d.query(tx, q)
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	defer rows.Close()

	return d.scanRuns(rows)
}

func (d *DB) scanRun(rows *stdsql.Rows, additionalFields []interface{}) (*types.Run, string, error) {
	var id string
	var revision uint64
	var data []byte
	fields := append([]interface{}{&id, &revision, &data}, additionalFields...)
	if err := rows.Scan(fields...); err != nil {
		return nil, "", errors.Wrap(err, "failed to scan rows")
	}
	v := types.Run{}
	if len(data) > 0 {
		if err := json.Unmarshal(data, &v); err != nil {
			return nil, "", errors.Wrap(err, "failed to unmarshal Run")
		}
	}

	v.Revision = revision

	return &v, id, nil
}

func (d *DB) scanRuns(rows *stdsql.Rows) ([]*types.Run, []string, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	fieldsNumber := len(cols)
	if fieldsNumber < 3 {
		return nil, nil, errors.Errorf("not enough columns (%d < 3)", len(cols))
	}
	var additionalFieldsPtr []interface{}
	if fieldsNumber > 3 {
		additionalFieldsNumber := fieldsNumber - 3
		additionalFields := make([]interface{}, additionalFieldsNumber)
		additionalFieldsPtr = make([]interface{}, additionalFieldsNumber)
		for i := 0; i < additionalFieldsNumber; i++ {
			additionalFieldsPtr[i] = &additionalFields[i]
		}
	}

	vs := []*types.Run{}
	ids := []string{}
	for rows.Next() {
		v, id, err := d.scanRun(rows, additionalFieldsPtr)
		if err != nil {
			rows.Close()
			return nil, nil, errors.WithStack(err)
		}
		vs = append(vs, v)
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, nil, errors.WithStack(err)
	}
	return vs, ids, nil
}

func (d *DB) fetchRunConfigs(tx *sql.Tx, q sq.Sqlizer) ([]*types.RunConfig, []string, error) {
	rows, err := d.query(tx, q)
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	defer rows.Close()

	return d.scanRunConfigs(rows)
}

func (d *DB) scanRunConfig(rows *stdsql.Rows, additionalFields []interface{}) (*types.RunConfig, string, error) {
	var id string
	var revision uint64
	var data []byte
	fields := append([]interface{}{&id, &revision, &data}, additionalFields...)
	if err := rows.Scan(fields...); err != nil {
		return nil, "", errors.Wrap(err, "failed to scan rows")
	}
	v := types.RunConfig{}
	if len(data) > 0 {
		if err := json.Unmarshal(data, &v); err != nil {
			return nil, "", errors.Wrap(err, "failed to unmarshal RunConfig")
		}
	}

	v.Revision = revision

	return &v, id, nil
}

func (d *DB) scanRunConfigs(rows *stdsql.Rows) ([]*types.RunConfig, []string, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	fieldsNumber := len(cols)
	if fieldsNumber < 3 {
		return nil, nil, errors.Errorf("not enough columns (%d < 3)", len(cols))
	}
	var additionalFieldsPtr []interface{}
	if fieldsNumber > 3 {
		additionalFieldsNumber := fieldsNumber - 3
		additionalFields := make([]interface{}, additionalFieldsNumber)
		additionalFieldsPtr = make([]interface{}, additionalFieldsNumber)
		for i := 0; i < additionalFieldsNumber; i++ {
			additionalFieldsPtr[i] = &additionalFields[i]
		}
	}

	vs := []*types.RunConfig{}
	ids := []string{}
	for rows.Next() {
		v, id, err := d.scanRunConfig(rows, additionalFieldsPtr)
		if err != nil {
			rows.Close()
			return nil, nil, errors.WithStack(err)
		}
		vs = append(vs, v)
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, nil, errors.WithStack(err)
	}
	return vs, ids, nil
}

func (d *DB) fetchRunCounters(tx *sql.Tx, q sq.Sqlizer) ([]*types.RunCounter, []string, error) {
	rows, err := d.query(tx, q)
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	defer rows.Close()

	return d.scanRunCounters(rows)
}

func (d *DB) scanRunCounter(rows *stdsql.Rows, additionalFields []interface{}) (*types.RunCounter, string, error) {
	var id string
	var revision uint64
	var data []byte
	fields := append([]interface{}{&id, &revision, &data}, additionalFields...)
	if err := rows.Scan(fields...); err != nil {
		return nil, "", errors.Wrap(err, "failed to scan rows")
	}
	v := types.RunCounter{}
	if len(data) > 0 {
		if err := json.Unmarshal(data, &v); err != nil {
			return nil, "", errors.Wrap(err, "failed to unmarshal RunCounter")
		}
	}

	v.Revision = revision

	return &v, id, nil
}

func (d *DB) scanRunCounters(rows *stdsql.Rows) ([]*types.RunCounter, []string, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	fieldsNumber := len(cols)
	if fieldsNumber < 3 {
		return nil, nil, errors.Errorf("not enough columns (%d < 3)", len(cols))
	}
	var additionalFieldsPtr []interface{}
	if fieldsNumber > 3 {
		additionalFieldsNumber := fieldsNumber - 3
		additionalFields := make([]interface{}, additionalFieldsNumber)
		additionalFieldsPtr = make([]interface{}, additionalFieldsNumber)
		for i := 0; i < additionalFieldsNumber; i++ {
			additionalFieldsPtr[i] = &additionalFields[i]
		}
	}

	vs := []*types.RunCounter{}
	ids := []string{}
	for rows.Next() {
		v, id, err := d.scanRunCounter(rows, additionalFieldsPtr)
		if err != nil {
			rows.Close()
			return nil, nil, errors.WithStack(err)
		}
		vs = append(vs, v)
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, nil, errors.WithStack(err)
	}
	return vs, ids, nil
}

func (d *DB) fetchRunEvents(tx *sql.Tx, q sq.Sqlizer) ([]*types.RunEvent, []string, error) {
	rows, err := d.query(tx, q)
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	defer rows.Close()

	return d.scanRunEvents(rows)
}

func (d *DB) scanRunEvent(rows *stdsql.Rows, additionalFields []interface{}) (*types.RunEvent, string, error) {
	var id string
	var revision uint64
	var data []byte
	fields := append([]interface{}{&id, &revision, &data}, additionalFields...)
	if err := rows.Scan(fields...); err != nil {
		return nil, "", errors.Wrap(err, "failed to scan rows")
	}
	v := types.RunEvent{}
	if len(data) > 0 {
		if err := json.Unmarshal(data, &v); err != nil {
			return nil, "", errors.Wrap(err, "failed to unmarshal RunEvent")
		}
	}

	v.Revision = revision

	return &v, id, nil
}

func (d *DB) scanRunEvents(rows *stdsql.Rows) ([]*types.RunEvent, []string, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	fieldsNumber := len(cols)
	if fieldsNumber < 3 {
		return nil, nil, errors.Errorf("not enough columns (%d < 3)", len(cols))
	}
	var additionalFieldsPtr []interface{}
	if fieldsNumber > 3 {
		additionalFieldsNumber := fieldsNumber - 3
		additionalFields := make([]interface{}, additionalFieldsNumber)
		additionalFieldsPtr = make([]interface{}, additionalFieldsNumber)
		for i := 0; i < additionalFieldsNumber; i++ {
			additionalFieldsPtr[i] = &additionalFields[i]
		}
	}

	vs := []*types.RunEvent{}
	ids := []string{}
	for rows.Next() {
		v, id, err := d.scanRunEvent(rows, additionalFieldsPtr)
		if err != nil {
			rows.Close()
			return nil, nil, errors.WithStack(err)
		}
		vs = append(vs, v)
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, nil, errors.WithStack(err)
	}
	return vs, ids, nil
}

func (d *DB) fetchExecutors(tx *sql.Tx, q sq.Sqlizer) ([]*types.Executor, []string, error) {
	rows, err := d.query(tx, q)
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	defer rows.Close()

	return d.scanExecutors(rows)
}

func (d *DB) scanExecutor(rows *stdsql.Rows, additionalFields []interface{}) (*types.Executor, string, error) {
	var id string
	var revision uint64
	var data []byte
	fields := append([]interface{}{&id, &revision, &data}, additionalFields...)
	if err := rows.Scan(fields...); err != nil {
		return nil, "", errors.Wrap(err, "failed to scan rows")
	}
	v := types.Executor{}
	if len(data) > 0 {
		if err := json.Unmarshal(data, &v); err != nil {
			return nil, "", errors.Wrap(err, "failed to unmarshal Executor")
		}
	}

	v.Revision = revision

	return &v, id, nil
}

func (d *DB) scanExecutors(rows *stdsql.Rows) ([]*types.Executor, []string, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	fieldsNumber := len(cols)
	if fieldsNumber < 3 {
		return nil, nil, errors.Errorf("not enough columns (%d < 3)", len(cols))
	}
	var additionalFieldsPtr []interface{}
	if fieldsNumber > 3 {
		additionalFieldsNumber := fieldsNumber - 3
		additionalFields := make([]interface{}, additionalFieldsNumber)
		additionalFieldsPtr = make([]interface{}, additionalFieldsNumber)
		for i := 0; i < additionalFieldsNumber; i++ {
			additionalFieldsPtr[i] = &additionalFields[i]
		}
	}

	vs := []*types.Executor{}
	ids := []string{}
	for rows.Next() {
		v, id, err := d.scanExecutor(rows, additionalFieldsPtr)
		if err != nil {
			rows.Close()
			return nil, nil, errors.WithStack(err)
		}
		vs = append(vs, v)
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, nil, errors.WithStack(err)
	}
	return vs, ids, nil
}

func (d *DB) fetchExecutorTasks(tx *sql.Tx, q sq.Sqlizer) ([]*types.ExecutorTask, []string, error) {
	rows, err := d.query(tx, q)
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	defer rows.Close()

	return d.scanExecutorTasks(rows)
}

func (d *DB) scanExecutorTask(rows *stdsql.Rows, additionalFields []interface{}) (*types.ExecutorTask, string, error) {
	var id string
	var revision uint64
	var data []byte
	fields := append([]interface{}{&id, &revision, &data}, additionalFields...)
	if err := rows.Scan(fields...); err != nil {
		return nil, "", errors.Wrap(err, "failed to scan rows")
	}
	v := types.ExecutorTask{}
	if len(data) > 0 {
		if err := json.Unmarshal(data, &v); err != nil {
			return nil, "", errors.Wrap(err, "failed to unmarshal ExecutorTask")
		}
	}

	v.Revision = revision

	return &v, id, nil
}

func (d *DB) scanExecutorTasks(rows *stdsql.Rows) ([]*types.ExecutorTask, []string, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, nil, errors.WithStack(err)
	}
	fieldsNumber := len(cols)
	if fieldsNumber < 3 {
		return nil, nil, errors.Errorf("not enough columns (%d < 3)", len(cols))
	}
	var additionalFieldsPtr []interface{}
	if fieldsNumber > 3 {
		additionalFieldsNumber := fieldsNumber - 3
		additionalFields := make([]interface{}, additionalFieldsNumber)
		additionalFieldsPtr = make([]interface{}, additionalFieldsNumber)
		for i := 0; i < additionalFieldsNumber; i++ {
			additionalFieldsPtr[i] = &additionalFields[i]
		}
	}

	vs := []*types.ExecutorTask{}
	ids := []string{}
	for rows.Next() {
		v, id, err := d.scanExecutorTask(rows, additionalFieldsPtr)
		if err != nil {
			rows.Close()
			return nil, nil, errors.WithStack(err)
		}
		vs = append(vs, v)
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, nil, errors.WithStack(err)
	}
	return vs, ids, nil
}
