// Code generated by go generate; DO NOT EDIT.
package db

import (
	"encoding/json"
	stdsql "database/sql"
	"time"

	"github.com/sorintlab/errors"
	sq "github.com/huandu/go-sqlbuilder"

	"agola.io/agola/internal/sqlg/sql"

	types "agola.io/agola/services/configstore/types"
)
var (
	remoteSourceInsertPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inAPIURL string, inSkipVerify bool, inType types.RemoteSourceType, inAuthType types.RemoteSourceAuthType, inOauth2ClientID string, inOauth2ClientSecret string, inSSHHostKey string, inSkipSSHHostKeyCheck bool, inRegistrationEnabled bool, inLoginEnabled bool) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("remotesource").Cols("id", "revision", "creation_time", "update_time", "name", "apiurl", "skip_verify", "type", "auth_type", "oauth2_client_id", "oauth2_client_secret", "ssh_host_key", "skip_ssh_host_key_check", "registration_enabled", "login_enabled").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inAPIURL, inSkipVerify, inType, inAuthType, inOauth2ClientID, inOauth2ClientSecret, inSSHHostKey, inSkipSSHHostKeyCheck, inRegistrationEnabled, inLoginEnabled)
	}
	remoteSourceUpdatePostgres = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inAPIURL string, inSkipVerify bool, inType types.RemoteSourceType, inAuthType types.RemoteSourceAuthType, inOauth2ClientID string, inOauth2ClientSecret string, inSSHHostKey string, inSkipSSHHostKeyCheck bool, inRegistrationEnabled bool, inLoginEnabled bool) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("remotesource").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("name", inName), ub.Assign("apiurl", inAPIURL), ub.Assign("skip_verify", inSkipVerify), ub.Assign("type", inType), ub.Assign("auth_type", inAuthType), ub.Assign("oauth2_client_id", inOauth2ClientID), ub.Assign("oauth2_client_secret", inOauth2ClientSecret), ub.Assign("ssh_host_key", inSSHHostKey), ub.Assign("skip_ssh_host_key_check", inSkipSSHHostKeyCheck), ub.Assign("registration_enabled", inRegistrationEnabled), ub.Assign("login_enabled", inLoginEnabled)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	remoteSourceInsertRawPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inAPIURL string, inSkipVerify bool, inType types.RemoteSourceType, inAuthType types.RemoteSourceAuthType, inOauth2ClientID string, inOauth2ClientSecret string, inSSHHostKey string, inSkipSSHHostKeyCheck bool, inRegistrationEnabled bool, inLoginEnabled bool) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("remotesource").Cols("id", "revision", "creation_time", "update_time", "name", "apiurl", "skip_verify", "type", "auth_type", "oauth2_client_id", "oauth2_client_secret", "ssh_host_key", "skip_ssh_host_key_check", "registration_enabled", "login_enabled").SQL("OVERRIDING SYSTEM VALUE").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inAPIURL, inSkipVerify, inType, inAuthType, inOauth2ClientID, inOauth2ClientSecret, inSSHHostKey, inSkipSSHHostKeyCheck, inRegistrationEnabled, inLoginEnabled)
	}
)

func (d *DB) insertRemoteSourcePostgres(tx *sql.Tx, remotesource *types.RemoteSource) error {
	q := remoteSourceInsertPostgres(remotesource.ID, remotesource.Revision, remotesource.CreationTime, remotesource.UpdateTime, remotesource.Name, remotesource.APIURL, remotesource.SkipVerify, remotesource.Type, remotesource.AuthType, remotesource.Oauth2ClientID, remotesource.Oauth2ClientSecret, remotesource.SSHHostKey, remotesource.SkipSSHHostKeyCheck, remotesource.RegistrationEnabled, remotesource.LoginEnabled)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert remoteSource")
	}

	return nil
}

func (d *DB) updateRemoteSourcePostgres(tx *sql.Tx, curRevision uint64, remotesource *types.RemoteSource) (stdsql.Result, error) {
	q := remoteSourceUpdatePostgres(curRevision, remotesource.ID, remotesource.Revision, remotesource.CreationTime, remotesource.UpdateTime, remotesource.Name, remotesource.APIURL, remotesource.SkipVerify, remotesource.Type, remotesource.AuthType, remotesource.Oauth2ClientID, remotesource.Oauth2ClientSecret, remotesource.SSHHostKey, remotesource.SkipSSHHostKeyCheck, remotesource.RegistrationEnabled, remotesource.LoginEnabled)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update remoteSource")
	}

	return res, nil
}

func (d *DB) insertRawRemoteSourcePostgres(tx *sql.Tx, remotesource *types.RemoteSource) error {
	q := remoteSourceInsertRawPostgres(remotesource.ID, remotesource.Revision, remotesource.CreationTime, remotesource.UpdateTime, remotesource.Name, remotesource.APIURL, remotesource.SkipVerify, remotesource.Type, remotesource.AuthType, remotesource.Oauth2ClientID, remotesource.Oauth2ClientSecret, remotesource.SSHHostKey, remotesource.SkipSSHHostKeyCheck, remotesource.RegistrationEnabled, remotesource.LoginEnabled)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert remoteSource")
	}

	return nil
}
var (
	userInsertPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inSecret string, inAdmin bool) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("user_t").Cols("id", "revision", "creation_time", "update_time", "name", "secret", "admin").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inSecret, inAdmin)
	}
	userUpdatePostgres = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inSecret string, inAdmin bool) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("user_t").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("name", inName), ub.Assign("secret", inSecret), ub.Assign("admin", inAdmin)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	userInsertRawPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inSecret string, inAdmin bool) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("user_t").Cols("id", "revision", "creation_time", "update_time", "name", "secret", "admin").SQL("OVERRIDING SYSTEM VALUE").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inSecret, inAdmin)
	}
)

func (d *DB) insertUserPostgres(tx *sql.Tx, user *types.User) error {
	q := userInsertPostgres(user.ID, user.Revision, user.CreationTime, user.UpdateTime, user.Name, user.Secret, user.Admin)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert user")
	}

	return nil
}

func (d *DB) updateUserPostgres(tx *sql.Tx, curRevision uint64, user *types.User) (stdsql.Result, error) {
	q := userUpdatePostgres(curRevision, user.ID, user.Revision, user.CreationTime, user.UpdateTime, user.Name, user.Secret, user.Admin)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update user")
	}

	return res, nil
}

func (d *DB) insertRawUserPostgres(tx *sql.Tx, user *types.User) error {
	q := userInsertRawPostgres(user.ID, user.Revision, user.CreationTime, user.UpdateTime, user.Name, user.Secret, user.Admin)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert user")
	}

	return nil
}
var (
	userTokenInsertPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inUserID string, inName string, inValue string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("usertoken").Cols("id", "revision", "creation_time", "update_time", "user_id", "name", "value").Values(inId, inRevision, inCreationTime, inUpdateTime, inUserID, inName, inValue)
	}
	userTokenUpdatePostgres = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inUserID string, inName string, inValue string) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("usertoken").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("user_id", inUserID), ub.Assign("name", inName), ub.Assign("value", inValue)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	userTokenInsertRawPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inUserID string, inName string, inValue string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("usertoken").Cols("id", "revision", "creation_time", "update_time", "user_id", "name", "value").SQL("OVERRIDING SYSTEM VALUE").Values(inId, inRevision, inCreationTime, inUpdateTime, inUserID, inName, inValue)
	}
)

func (d *DB) insertUserTokenPostgres(tx *sql.Tx, usertoken *types.UserToken) error {
	q := userTokenInsertPostgres(usertoken.ID, usertoken.Revision, usertoken.CreationTime, usertoken.UpdateTime, usertoken.UserID, usertoken.Name, usertoken.Value)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert userToken")
	}

	return nil
}

func (d *DB) updateUserTokenPostgres(tx *sql.Tx, curRevision uint64, usertoken *types.UserToken) (stdsql.Result, error) {
	q := userTokenUpdatePostgres(curRevision, usertoken.ID, usertoken.Revision, usertoken.CreationTime, usertoken.UpdateTime, usertoken.UserID, usertoken.Name, usertoken.Value)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update userToken")
	}

	return res, nil
}

func (d *DB) insertRawUserTokenPostgres(tx *sql.Tx, usertoken *types.UserToken) error {
	q := userTokenInsertRawPostgres(usertoken.ID, usertoken.Revision, usertoken.CreationTime, usertoken.UpdateTime, usertoken.UserID, usertoken.Name, usertoken.Value)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert userToken")
	}

	return nil
}
var (
	linkedAccountInsertPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inUserID string, inRemoteUserID string, inRemoteUserName string, inRemoteUserAvatarURL string, inRemoteSourceID string, inUserAccessToken string, inOauth2AccessToken string, inOauth2RefreshToken string, inOauth2AccessTokenExpiresAt time.Time) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("linkedaccount").Cols("id", "revision", "creation_time", "update_time", "user_id", "remote_user_id", "remote_user_name", "remote_user_avatar_url", "remote_source_id", "user_access_token", "oauth2_access_token", "oauth2_refresh_token", "oauth2_access_token_expires_at").Values(inId, inRevision, inCreationTime, inUpdateTime, inUserID, inRemoteUserID, inRemoteUserName, inRemoteUserAvatarURL, inRemoteSourceID, inUserAccessToken, inOauth2AccessToken, inOauth2RefreshToken, inOauth2AccessTokenExpiresAt)
	}
	linkedAccountUpdatePostgres = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inUserID string, inRemoteUserID string, inRemoteUserName string, inRemoteUserAvatarURL string, inRemoteSourceID string, inUserAccessToken string, inOauth2AccessToken string, inOauth2RefreshToken string, inOauth2AccessTokenExpiresAt time.Time) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("linkedaccount").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("user_id", inUserID), ub.Assign("remote_user_id", inRemoteUserID), ub.Assign("remote_user_name", inRemoteUserName), ub.Assign("remote_user_avatar_url", inRemoteUserAvatarURL), ub.Assign("remote_source_id", inRemoteSourceID), ub.Assign("user_access_token", inUserAccessToken), ub.Assign("oauth2_access_token", inOauth2AccessToken), ub.Assign("oauth2_refresh_token", inOauth2RefreshToken), ub.Assign("oauth2_access_token_expires_at", inOauth2AccessTokenExpiresAt)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	linkedAccountInsertRawPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inUserID string, inRemoteUserID string, inRemoteUserName string, inRemoteUserAvatarURL string, inRemoteSourceID string, inUserAccessToken string, inOauth2AccessToken string, inOauth2RefreshToken string, inOauth2AccessTokenExpiresAt time.Time) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("linkedaccount").Cols("id", "revision", "creation_time", "update_time", "user_id", "remote_user_id", "remote_user_name", "remote_user_avatar_url", "remote_source_id", "user_access_token", "oauth2_access_token", "oauth2_refresh_token", "oauth2_access_token_expires_at").SQL("OVERRIDING SYSTEM VALUE").Values(inId, inRevision, inCreationTime, inUpdateTime, inUserID, inRemoteUserID, inRemoteUserName, inRemoteUserAvatarURL, inRemoteSourceID, inUserAccessToken, inOauth2AccessToken, inOauth2RefreshToken, inOauth2AccessTokenExpiresAt)
	}
)

func (d *DB) insertLinkedAccountPostgres(tx *sql.Tx, linkedaccount *types.LinkedAccount) error {
	q := linkedAccountInsertPostgres(linkedaccount.ID, linkedaccount.Revision, linkedaccount.CreationTime, linkedaccount.UpdateTime, linkedaccount.UserID, linkedaccount.RemoteUserID, linkedaccount.RemoteUserName, linkedaccount.RemoteUserAvatarURL, linkedaccount.RemoteSourceID, linkedaccount.UserAccessToken, linkedaccount.Oauth2AccessToken, linkedaccount.Oauth2RefreshToken, linkedaccount.Oauth2AccessTokenExpiresAt)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert linkedAccount")
	}

	return nil
}

func (d *DB) updateLinkedAccountPostgres(tx *sql.Tx, curRevision uint64, linkedaccount *types.LinkedAccount) (stdsql.Result, error) {
	q := linkedAccountUpdatePostgres(curRevision, linkedaccount.ID, linkedaccount.Revision, linkedaccount.CreationTime, linkedaccount.UpdateTime, linkedaccount.UserID, linkedaccount.RemoteUserID, linkedaccount.RemoteUserName, linkedaccount.RemoteUserAvatarURL, linkedaccount.RemoteSourceID, linkedaccount.UserAccessToken, linkedaccount.Oauth2AccessToken, linkedaccount.Oauth2RefreshToken, linkedaccount.Oauth2AccessTokenExpiresAt)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update linkedAccount")
	}

	return res, nil
}

func (d *DB) insertRawLinkedAccountPostgres(tx *sql.Tx, linkedaccount *types.LinkedAccount) error {
	q := linkedAccountInsertRawPostgres(linkedaccount.ID, linkedaccount.Revision, linkedaccount.CreationTime, linkedaccount.UpdateTime, linkedaccount.UserID, linkedaccount.RemoteUserID, linkedaccount.RemoteUserName, linkedaccount.RemoteUserAvatarURL, linkedaccount.RemoteSourceID, linkedaccount.UserAccessToken, linkedaccount.Oauth2AccessToken, linkedaccount.Oauth2RefreshToken, linkedaccount.Oauth2AccessTokenExpiresAt)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert linkedAccount")
	}

	return nil
}
var (
	organizationInsertPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inVisibility types.Visibility, inCreatorUserID string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("organization").Cols("id", "revision", "creation_time", "update_time", "name", "visibility", "creator_user_id").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inVisibility, inCreatorUserID)
	}
	organizationUpdatePostgres = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inVisibility types.Visibility, inCreatorUserID string) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("organization").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("name", inName), ub.Assign("visibility", inVisibility), ub.Assign("creator_user_id", inCreatorUserID)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	organizationInsertRawPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inVisibility types.Visibility, inCreatorUserID string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("organization").Cols("id", "revision", "creation_time", "update_time", "name", "visibility", "creator_user_id").SQL("OVERRIDING SYSTEM VALUE").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inVisibility, inCreatorUserID)
	}
)

func (d *DB) insertOrganizationPostgres(tx *sql.Tx, organization *types.Organization) error {
	q := organizationInsertPostgres(organization.ID, organization.Revision, organization.CreationTime, organization.UpdateTime, organization.Name, organization.Visibility, organization.CreatorUserID)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert organization")
	}

	return nil
}

func (d *DB) updateOrganizationPostgres(tx *sql.Tx, curRevision uint64, organization *types.Organization) (stdsql.Result, error) {
	q := organizationUpdatePostgres(curRevision, organization.ID, organization.Revision, organization.CreationTime, organization.UpdateTime, organization.Name, organization.Visibility, organization.CreatorUserID)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update organization")
	}

	return res, nil
}

func (d *DB) insertRawOrganizationPostgres(tx *sql.Tx, organization *types.Organization) error {
	q := organizationInsertRawPostgres(organization.ID, organization.Revision, organization.CreationTime, organization.UpdateTime, organization.Name, organization.Visibility, organization.CreatorUserID)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert organization")
	}

	return nil
}
var (
	organizationMemberInsertPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inOrganizationID string, inUserID string, inMemberRole types.MemberRole) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("orgmember").Cols("id", "revision", "creation_time", "update_time", "organization_id", "user_id", "member_role").Values(inId, inRevision, inCreationTime, inUpdateTime, inOrganizationID, inUserID, inMemberRole)
	}
	organizationMemberUpdatePostgres = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inOrganizationID string, inUserID string, inMemberRole types.MemberRole) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("orgmember").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("organization_id", inOrganizationID), ub.Assign("user_id", inUserID), ub.Assign("member_role", inMemberRole)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	organizationMemberInsertRawPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inOrganizationID string, inUserID string, inMemberRole types.MemberRole) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("orgmember").Cols("id", "revision", "creation_time", "update_time", "organization_id", "user_id", "member_role").SQL("OVERRIDING SYSTEM VALUE").Values(inId, inRevision, inCreationTime, inUpdateTime, inOrganizationID, inUserID, inMemberRole)
	}
)

func (d *DB) insertOrganizationMemberPostgres(tx *sql.Tx, organizationmember *types.OrganizationMember) error {
	q := organizationMemberInsertPostgres(organizationmember.ID, organizationmember.Revision, organizationmember.CreationTime, organizationmember.UpdateTime, organizationmember.OrganizationID, organizationmember.UserID, organizationmember.MemberRole)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert organizationMember")
	}

	return nil
}

func (d *DB) updateOrganizationMemberPostgres(tx *sql.Tx, curRevision uint64, organizationmember *types.OrganizationMember) (stdsql.Result, error) {
	q := organizationMemberUpdatePostgres(curRevision, organizationmember.ID, organizationmember.Revision, organizationmember.CreationTime, organizationmember.UpdateTime, organizationmember.OrganizationID, organizationmember.UserID, organizationmember.MemberRole)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update organizationMember")
	}

	return res, nil
}

func (d *DB) insertRawOrganizationMemberPostgres(tx *sql.Tx, organizationmember *types.OrganizationMember) error {
	q := organizationMemberInsertRawPostgres(organizationmember.ID, organizationmember.Revision, organizationmember.CreationTime, organizationmember.UpdateTime, organizationmember.OrganizationID, organizationmember.UserID, organizationmember.MemberRole)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert organizationMember")
	}

	return nil
}
var (
	projectGroupInsertPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inVisibility types.Visibility) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("projectgroup").Cols("id", "revision", "creation_time", "update_time", "name", "parent_kind", "parent_id", "visibility").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inParentKind, inParentID, inVisibility)
	}
	projectGroupUpdatePostgres = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inVisibility types.Visibility) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("projectgroup").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("name", inName), ub.Assign("parent_kind", inParentKind), ub.Assign("parent_id", inParentID), ub.Assign("visibility", inVisibility)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	projectGroupInsertRawPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inVisibility types.Visibility) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("projectgroup").Cols("id", "revision", "creation_time", "update_time", "name", "parent_kind", "parent_id", "visibility").SQL("OVERRIDING SYSTEM VALUE").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inParentKind, inParentID, inVisibility)
	}
)

func (d *DB) insertProjectGroupPostgres(tx *sql.Tx, projectgroup *types.ProjectGroup) error {
	q := projectGroupInsertPostgres(projectgroup.ID, projectgroup.Revision, projectgroup.CreationTime, projectgroup.UpdateTime, projectgroup.Name, projectgroup.Parent.Kind, projectgroup.Parent.ID, projectgroup.Visibility)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert projectGroup")
	}

	return nil
}

func (d *DB) updateProjectGroupPostgres(tx *sql.Tx, curRevision uint64, projectgroup *types.ProjectGroup) (stdsql.Result, error) {
	q := projectGroupUpdatePostgres(curRevision, projectgroup.ID, projectgroup.Revision, projectgroup.CreationTime, projectgroup.UpdateTime, projectgroup.Name, projectgroup.Parent.Kind, projectgroup.Parent.ID, projectgroup.Visibility)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update projectGroup")
	}

	return res, nil
}

func (d *DB) insertRawProjectGroupPostgres(tx *sql.Tx, projectgroup *types.ProjectGroup) error {
	q := projectGroupInsertRawPostgres(projectgroup.ID, projectgroup.Revision, projectgroup.CreationTime, projectgroup.UpdateTime, projectgroup.Name, projectgroup.Parent.Kind, projectgroup.Parent.ID, projectgroup.Visibility)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert projectGroup")
	}

	return nil
}
var (
	projectInsertPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inSecret string, inVisibility types.Visibility, inRemoteRepositoryConfigType types.RemoteRepositoryConfigType, inRemoteSourceID string, inLinkedAccountID string, inRepositoryID string, inRepositoryPath string, inSSHPrivateKey string, inSkipSSHHostKeyCheck bool, inWebhookSecret string, inPassVarsToForkedPR bool, inDefaultBranch string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("project").Cols("id", "revision", "creation_time", "update_time", "name", "parent_kind", "parent_id", "secret", "visibility", "remote_repository_config_type", "remote_source_id", "linked_account_id", "repository_id", "repository_path", "ssh_private_key", "skip_ssh_host_key_check", "webhook_secret", "pass_vars_to_forked_pr", "default_branch").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inParentKind, inParentID, inSecret, inVisibility, inRemoteRepositoryConfigType, inRemoteSourceID, inLinkedAccountID, inRepositoryID, inRepositoryPath, inSSHPrivateKey, inSkipSSHHostKeyCheck, inWebhookSecret, inPassVarsToForkedPR, inDefaultBranch)
	}
	projectUpdatePostgres = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inSecret string, inVisibility types.Visibility, inRemoteRepositoryConfigType types.RemoteRepositoryConfigType, inRemoteSourceID string, inLinkedAccountID string, inRepositoryID string, inRepositoryPath string, inSSHPrivateKey string, inSkipSSHHostKeyCheck bool, inWebhookSecret string, inPassVarsToForkedPR bool, inDefaultBranch string) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("project").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("name", inName), ub.Assign("parent_kind", inParentKind), ub.Assign("parent_id", inParentID), ub.Assign("secret", inSecret), ub.Assign("visibility", inVisibility), ub.Assign("remote_repository_config_type", inRemoteRepositoryConfigType), ub.Assign("remote_source_id", inRemoteSourceID), ub.Assign("linked_account_id", inLinkedAccountID), ub.Assign("repository_id", inRepositoryID), ub.Assign("repository_path", inRepositoryPath), ub.Assign("ssh_private_key", inSSHPrivateKey), ub.Assign("skip_ssh_host_key_check", inSkipSSHHostKeyCheck), ub.Assign("webhook_secret", inWebhookSecret), ub.Assign("pass_vars_to_forked_pr", inPassVarsToForkedPR), ub.Assign("default_branch", inDefaultBranch)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	projectInsertRawPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inSecret string, inVisibility types.Visibility, inRemoteRepositoryConfigType types.RemoteRepositoryConfigType, inRemoteSourceID string, inLinkedAccountID string, inRepositoryID string, inRepositoryPath string, inSSHPrivateKey string, inSkipSSHHostKeyCheck bool, inWebhookSecret string, inPassVarsToForkedPR bool, inDefaultBranch string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("project").Cols("id", "revision", "creation_time", "update_time", "name", "parent_kind", "parent_id", "secret", "visibility", "remote_repository_config_type", "remote_source_id", "linked_account_id", "repository_id", "repository_path", "ssh_private_key", "skip_ssh_host_key_check", "webhook_secret", "pass_vars_to_forked_pr", "default_branch").SQL("OVERRIDING SYSTEM VALUE").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inParentKind, inParentID, inSecret, inVisibility, inRemoteRepositoryConfigType, inRemoteSourceID, inLinkedAccountID, inRepositoryID, inRepositoryPath, inSSHPrivateKey, inSkipSSHHostKeyCheck, inWebhookSecret, inPassVarsToForkedPR, inDefaultBranch)
	}
)

func (d *DB) insertProjectPostgres(tx *sql.Tx, project *types.Project) error {
	q := projectInsertPostgres(project.ID, project.Revision, project.CreationTime, project.UpdateTime, project.Name, project.Parent.Kind, project.Parent.ID, project.Secret, project.Visibility, project.RemoteRepositoryConfigType, project.RemoteSourceID, project.LinkedAccountID, project.RepositoryID, project.RepositoryPath, project.SSHPrivateKey, project.SkipSSHHostKeyCheck, project.WebhookSecret, project.PassVarsToForkedPR, project.DefaultBranch)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert project")
	}

	return nil
}

func (d *DB) updateProjectPostgres(tx *sql.Tx, curRevision uint64, project *types.Project) (stdsql.Result, error) {
	q := projectUpdatePostgres(curRevision, project.ID, project.Revision, project.CreationTime, project.UpdateTime, project.Name, project.Parent.Kind, project.Parent.ID, project.Secret, project.Visibility, project.RemoteRepositoryConfigType, project.RemoteSourceID, project.LinkedAccountID, project.RepositoryID, project.RepositoryPath, project.SSHPrivateKey, project.SkipSSHHostKeyCheck, project.WebhookSecret, project.PassVarsToForkedPR, project.DefaultBranch)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update project")
	}

	return res, nil
}

func (d *DB) insertRawProjectPostgres(tx *sql.Tx, project *types.Project) error {
	q := projectInsertRawPostgres(project.ID, project.Revision, project.CreationTime, project.UpdateTime, project.Name, project.Parent.Kind, project.Parent.ID, project.Secret, project.Visibility, project.RemoteRepositoryConfigType, project.RemoteSourceID, project.LinkedAccountID, project.RepositoryID, project.RepositoryPath, project.SSHPrivateKey, project.SkipSSHHostKeyCheck, project.WebhookSecret, project.PassVarsToForkedPR, project.DefaultBranch)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert project")
	}

	return nil
}
var (
	secretInsertPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inType types.SecretType, inData []byte, inSecretProviderID string, inPath string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("secret").Cols("id", "revision", "creation_time", "update_time", "name", "parent_kind", "parent_id", "type", "data", "secret_provider_id", "path").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inParentKind, inParentID, inType, inData, inSecretProviderID, inPath)
	}
	secretUpdatePostgres = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inType types.SecretType, inData []byte, inSecretProviderID string, inPath string) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("secret").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("name", inName), ub.Assign("parent_kind", inParentKind), ub.Assign("parent_id", inParentID), ub.Assign("type", inType), ub.Assign("data", inData), ub.Assign("secret_provider_id", inSecretProviderID), ub.Assign("path", inPath)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	secretInsertRawPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inType types.SecretType, inData []byte, inSecretProviderID string, inPath string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("secret").Cols("id", "revision", "creation_time", "update_time", "name", "parent_kind", "parent_id", "type", "data", "secret_provider_id", "path").SQL("OVERRIDING SYSTEM VALUE").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inParentKind, inParentID, inType, inData, inSecretProviderID, inPath)
	}
)

func (d *DB) insertSecretPostgres(tx *sql.Tx, secret *types.Secret) error {
	inDataJSON, err := json.Marshal(secret.Data)
	if err != nil {
		return errors.Wrap(err, "failed to marshal secret.Data")
	}
	q := secretInsertPostgres(secret.ID, secret.Revision, secret.CreationTime, secret.UpdateTime, secret.Name, secret.Parent.Kind, secret.Parent.ID, secret.Type, inDataJSON, secret.SecretProviderID, secret.Path)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert secret")
	}

	return nil
}

func (d *DB) updateSecretPostgres(tx *sql.Tx, curRevision uint64, secret *types.Secret) (stdsql.Result, error) {
	inDataJSON, err := json.Marshal(secret.Data)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal secret.Data")
	}
	q := secretUpdatePostgres(curRevision, secret.ID, secret.Revision, secret.CreationTime, secret.UpdateTime, secret.Name, secret.Parent.Kind, secret.Parent.ID, secret.Type, inDataJSON, secret.SecretProviderID, secret.Path)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update secret")
	}

	return res, nil
}

func (d *DB) insertRawSecretPostgres(tx *sql.Tx, secret *types.Secret) error {
	inDataJSON, err := json.Marshal(secret.Data)
	if err != nil {
		return errors.Wrap(err, "failed to marshal secret.Data")
	}
	q := secretInsertRawPostgres(secret.ID, secret.Revision, secret.CreationTime, secret.UpdateTime, secret.Name, secret.Parent.Kind, secret.Parent.ID, secret.Type, inDataJSON, secret.SecretProviderID, secret.Path)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert secret")
	}

	return nil
}
var (
	variableInsertPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inValues []byte) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("variable").Cols("id", "revision", "creation_time", "update_time", "name", "parent_kind", "parent_id", "variable_values").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inParentKind, inParentID, inValues)
	}
	variableUpdatePostgres = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inValues []byte) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("variable").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("name", inName), ub.Assign("parent_kind", inParentKind), ub.Assign("parent_id", inParentID), ub.Assign("variable_values", inValues)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	variableInsertRawPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inParentKind types.ObjectKind, inParentID string, inValues []byte) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("variable").Cols("id", "revision", "creation_time", "update_time", "name", "parent_kind", "parent_id", "variable_values").SQL("OVERRIDING SYSTEM VALUE").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inParentKind, inParentID, inValues)
	}
)

func (d *DB) insertVariablePostgres(tx *sql.Tx, variable *types.Variable) error {
	inValuesJSON, err := json.Marshal(variable.Values)
	if err != nil {
		return errors.Wrap(err, "failed to marshal variable.Values")
	}
	q := variableInsertPostgres(variable.ID, variable.Revision, variable.CreationTime, variable.UpdateTime, variable.Name, variable.Parent.Kind, variable.Parent.ID, inValuesJSON)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert variable")
	}

	return nil
}

func (d *DB) updateVariablePostgres(tx *sql.Tx, curRevision uint64, variable *types.Variable) (stdsql.Result, error) {
	inValuesJSON, err := json.Marshal(variable.Values)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal variable.Values")
	}
	q := variableUpdatePostgres(curRevision, variable.ID, variable.Revision, variable.CreationTime, variable.UpdateTime, variable.Name, variable.Parent.Kind, variable.Parent.ID, inValuesJSON)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update variable")
	}

	return res, nil
}

func (d *DB) insertRawVariablePostgres(tx *sql.Tx, variable *types.Variable) error {
	inValuesJSON, err := json.Marshal(variable.Values)
	if err != nil {
		return errors.Wrap(err, "failed to marshal variable.Values")
	}
	q := variableInsertRawPostgres(variable.ID, variable.Revision, variable.CreationTime, variable.UpdateTime, variable.Name, variable.Parent.Kind, variable.Parent.ID, inValuesJSON)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert variable")
	}

	return nil
}
var (
	orgInvitationInsertPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inUserID string, inOrganizationID string, inRole types.MemberRole) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("orginvitation").Cols("id", "revision", "creation_time", "update_time", "user_id", "organization_id", "role").Values(inId, inRevision, inCreationTime, inUpdateTime, inUserID, inOrganizationID, inRole)
	}
	orgInvitationUpdatePostgres = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inUserID string, inOrganizationID string, inRole types.MemberRole) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("orginvitation").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("user_id", inUserID), ub.Assign("organization_id", inOrganizationID), ub.Assign("role", inRole)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	orgInvitationInsertRawPostgres = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inUserID string, inOrganizationID string, inRole types.MemberRole) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("orginvitation").Cols("id", "revision", "creation_time", "update_time", "user_id", "organization_id", "role").SQL("OVERRIDING SYSTEM VALUE").Values(inId, inRevision, inCreationTime, inUpdateTime, inUserID, inOrganizationID, inRole)
	}
)

func (d *DB) insertOrgInvitationPostgres(tx *sql.Tx, orginvitation *types.OrgInvitation) error {
	q := orgInvitationInsertPostgres(orginvitation.ID, orginvitation.Revision, orginvitation.CreationTime, orginvitation.UpdateTime, orginvitation.UserID, orginvitation.OrganizationID, orginvitation.Role)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert orgInvitation")
	}

	return nil
}

func (d *DB) updateOrgInvitationPostgres(tx *sql.Tx, curRevision uint64, orginvitation *types.OrgInvitation) (stdsql.Result, error) {
	q := orgInvitationUpdatePostgres(curRevision, orginvitation.ID, orginvitation.Revision, orginvitation.CreationTime, orginvitation.UpdateTime, orginvitation.UserID, orginvitation.OrganizationID, orginvitation.Role)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update orgInvitation")
	}

	return res, nil
}

func (d *DB) insertRawOrgInvitationPostgres(tx *sql.Tx, orginvitation *types.OrgInvitation) error {
	q := orgInvitationInsertRawPostgres(orginvitation.ID, orginvitation.Revision, orginvitation.CreationTime, orginvitation.UpdateTime, orginvitation.UserID, orginvitation.OrganizationID, orginvitation.Role)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert orgInvitation")
	}

	return nil
}
