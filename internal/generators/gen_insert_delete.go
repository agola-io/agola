package main

import (
	"os"
	"text/template"

	idb "agola.io/agola/internal/db"
	csobjects "agola.io/agola/internal/services/configstore/db/objects"
	rsobjects "agola.io/agola/internal/services/runservice/db/objects"
)

func genInsertDelete() {
	f, err := os.Create("insert_delete.go")
	if err != nil {
		panic(err)
	}

	defer f.Close()

	switch componentName {
	case "runservice":
		err = insertDeleteTemplate.Execute(f, struct {
			ObjectInfos []idb.ObjectInfo
			TypesPath   string
		}{
			ObjectInfos: rsobjects.ObjectsInfo,
			TypesPath:   "agola.io/agola/services/runservice/types",
		})
	case "configstore":
		err = insertDeleteTemplate.Execute(f, struct {
			ObjectInfos []idb.ObjectInfo
			TypesPath   string
		}{
			ObjectInfos: csobjects.ObjectsInfo,
			TypesPath:   "agola.io/agola/services/configstore/types",
		})
	}
	if err != nil {
		panic(err)
	}
}

var insertDeleteTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package db

import (
	"encoding/json"
	"time"

	idb "agola.io/agola/internal/db"
	"agola.io/agola/internal/errors"
	"agola.io/agola/internal/sql"
	"{{ .TypesPath }}"

	sq "github.com/Masterminds/squirrel"
)
{{- range $index, $oi := .ObjectInfos }}

func (d *DB) InsertOrUpdate{{ $oi.Name }}(tx *sql.Tx, v *types.{{ $oi.Name }}) error {
	var err error
	if v.Revision == 0 {
		err = d.Insert{{ $oi.Name }}(tx, v)
	} else {
		err = d.Update{{ $oi.Name }}(tx, v)
	}

	return errors.WithStack(err)
}

func (d *DB) Insert{{ $oi.Name }}(tx *sql.Tx, v *types.{{ $oi.Name }}) error {
	if v.Revision != 0 {
		return errors.Errorf("expected revision 0 got %d", v.Revision)
	}

	data, err := d.insert{{ $oi.Name }}Data(tx, v)
	if err != nil {
		return errors.WithStack(err)
	}

	return d.insert{{ $oi.Name }}Q(tx, v, data)
}

func (d *DB) insert{{ $oi.Name }}Data(tx *sql.Tx, v *types.{{ $oi.Name }}) ([]byte, error) {
	v.Revision = 1

	now := time.Now()
	v.SetCreationTime(now)
	v.SetUpdateTime(now)

	data, err := json.Marshal(v)
	if err != nil {
		v.Revision = 0
		return nil, errors.WithStack(err)
	}

	q := sb.Insert("{{ $oi.Table }}").Columns("id", "revision", "data").Values(v.ID, v.Revision, data)
	if _, err := d.exec(tx, q); err != nil {
		v.Revision = 0
		return nil, errors.Wrap(err, "failed to insert {{ $oi.Table }}")
	}

	return data, nil
}

// insertRaw{{ $oi.Name }}Data should be used only for import.
// It won't update object times.
func (d *DB) insertRaw{{ $oi.Name }}Data(tx *sql.Tx, v *types.{{ $oi.Name }}) ([]byte, error) {
	v.Revision = 1

	data, err := json.Marshal(v)
	if err != nil {
		v.Revision = 0
		return nil, errors.WithStack(err)
	}

	q := sb.Insert("{{ $oi.Table }}").Columns("id", "revision", "data").Values(v.ID, v.Revision, data)
	if _, err := d.exec(tx, q); err != nil {
		v.Revision = 0
		return nil, errors.Wrap(err, "failed to insert {{ $oi.Table }}")
	}

	return data, nil
}

func (d *DB) Update{{ $oi.Name }}(tx *sql.Tx, v *types.{{ $oi.Name }}) error {
	data, err := d.update{{ $oi.Name }}Data(tx, v)
	if err != nil {
		return errors.WithStack(err)
	}

	return d.update{{ $oi.Name }}Q(tx, v, data)
}

func (d *DB) update{{ $oi.Name }}Data(tx *sql.Tx, v *types.{{ $oi.Name }}) ([]byte, error) {
	if v.Revision < 1 {
		return nil, errors.Errorf("expected revision > 0 got %d", v.Revision)
	}

	curRevision := v.Revision
	v.Revision++

	v.SetUpdateTime(time.Now())

	data, err := json.Marshal(v)
	if err != nil {
		return nil, errors.WithStack(err)
	}

	q := sb.Update("{{ $oi.Table }}").SetMap(map[string]interface{}{"id": v.ID, "revision": v.Revision, "data": data}).Where(sq.Eq{"id": v.ID, "revision": curRevision})
	res, err := d.exec(tx, q)
	if err != nil {
		v.Revision = curRevision
		return nil, errors.Wrap(err, "failed to update {{ $oi.Table }}")
	}

	rows, err := res.RowsAffected()
	if err != nil {
		v.Revision = curRevision
		return nil, errors.Wrap(err, "failed to update {{ $oi.Table }}")
	}

	if rows != 1 {
		v.Revision = curRevision
		return nil, idb.ErrConcurrent
	}

	return data, nil
}

func (d *DB) Delete{{ $oi.Name }}(tx *sql.Tx, id string) error {
	if err := d.delete{{ $oi.Name }}Data(tx, id); err != nil {
		return errors.WithStack(err)
	}

	return d.delete{{ $oi.Name }}Q(tx, id)
}

func (d *DB) delete{{ $oi.Name }}Data(tx *sql.Tx, id string) error {
	if _, err := tx.Exec("delete from {{ $oi.Table }} where id = $1", id); err != nil {
		return errors.Wrap(err, "failed to delete {{ $oi.Table }}")
	}

	return nil
}

{{- end }}
`))
